// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable 618

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using JetBrains.Space.Common;
using JetBrains.Space.Common.Json.Serialization;
using JetBrains.Space.Common.Json.Serialization.Polymorphism;
using JetBrains.Space.Common.Types;

namespace JetBrains.Space.Client;

public class ApplicationsForApplicationPatchRequest
     : IPropagatePropertyAccessPath
{
    public ApplicationsForApplicationPatchRequest() { }
    
    public ApplicationsForApplicationPatchRequest(bool? endpointSslVerification = null, bool? hasVerificationToken = null, bool? hasPublicKeySignature = null, bool? hasSigningKey = null, EndpointAppLevelAuthUpdateType? appLevelAuth = null, string? basicAuthUsername = null, string? basicAuthPassword = null, string? bearerAuthToken = null, string? name = null, string? pictureAttachmentId = null, string? defaultExternalPicture = null, string? clientSecret = null, bool? clientCredentialsFlowEnabled = null, bool? codeFlowEnabled = null, string? codeFlowRedirectURIs = null, bool? pkceRequired = null, bool? implicitFlowEnabled = null, string? implicitFlowRedirectURIs = null, string? endpointUri = null, string? sslKeystoreAuth = null)
    {
        Name = name;
        PictureAttachmentId = pictureAttachmentId;
        DefaultExternalPicture = defaultExternalPicture;
        ClientSecret = clientSecret;
        IsClientCredentialsFlowEnabled = clientCredentialsFlowEnabled;
        IsCodeFlowEnabled = codeFlowEnabled;
        CodeFlowRedirectURIs = codeFlowRedirectURIs;
        IsPkceRequired = pkceRequired;
        IsImplicitFlowEnabled = implicitFlowEnabled;
        ImplicitFlowRedirectURIs = implicitFlowRedirectURIs;
        EndpointUri = endpointUri;
        IsEndpointSslVerification = endpointSslVerification;
        IsHasVerificationToken = hasVerificationToken;
        IsHasPublicKeySignature = hasPublicKeySignature;
        IsHasSigningKey = hasSigningKey;
        AppLevelAuth = appLevelAuth;
        SslKeystoreAuth = sslKeystoreAuth;
        BasicAuthUsername = basicAuthUsername;
        BasicAuthPassword = basicAuthPassword;
        BearerAuthToken = bearerAuthToken;
    }
    
    private PropertyValue<string?> _name = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(Name), "name");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("name")]
    public string? Name
    {
        get => _name.GetValue(InlineErrors);
        set => _name.SetValue(value);
    }

    private PropertyValue<string?> _pictureAttachmentId = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(PictureAttachmentId), "pictureAttachmentId");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("pictureAttachmentId")]
    public string? PictureAttachmentId
    {
        get => _pictureAttachmentId.GetValue(InlineErrors);
        set => _pictureAttachmentId.SetValue(value);
    }

    private PropertyValue<string?> _defaultExternalPicture = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(DefaultExternalPicture), "defaultExternalPicture");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("defaultExternalPicture")]
    public string? DefaultExternalPicture
    {
        get => _defaultExternalPicture.GetValue(InlineErrors);
        set => _defaultExternalPicture.SetValue(value);
    }

    private PropertyValue<string?> _clientSecret = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(ClientSecret), "clientSecret");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("clientSecret")]
    public string? ClientSecret
    {
        get => _clientSecret.GetValue(InlineErrors);
        set => _clientSecret.SetValue(value);
    }

    private PropertyValue<bool?> _clientCredentialsFlowEnabled = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsClientCredentialsFlowEnabled), "clientCredentialsFlowEnabled");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("clientCredentialsFlowEnabled")]
    public bool? IsClientCredentialsFlowEnabled
    {
        get => _clientCredentialsFlowEnabled.GetValue(InlineErrors);
        set => _clientCredentialsFlowEnabled.SetValue(value);
    }

    private PropertyValue<bool?> _codeFlowEnabled = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsCodeFlowEnabled), "codeFlowEnabled");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("codeFlowEnabled")]
    public bool? IsCodeFlowEnabled
    {
        get => _codeFlowEnabled.GetValue(InlineErrors);
        set => _codeFlowEnabled.SetValue(value);
    }

    private PropertyValue<string?> _codeFlowRedirectURIs = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(CodeFlowRedirectURIs), "codeFlowRedirectURIs");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("codeFlowRedirectURIs")]
    public string? CodeFlowRedirectURIs
    {
        get => _codeFlowRedirectURIs.GetValue(InlineErrors);
        set => _codeFlowRedirectURIs.SetValue(value);
    }

    private PropertyValue<bool?> _pkceRequired = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsPkceRequired), "pkceRequired");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("pkceRequired")]
    public bool? IsPkceRequired
    {
        get => _pkceRequired.GetValue(InlineErrors);
        set => _pkceRequired.SetValue(value);
    }

    private PropertyValue<bool?> _implicitFlowEnabled = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsImplicitFlowEnabled), "implicitFlowEnabled");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("implicitFlowEnabled")]
    public bool? IsImplicitFlowEnabled
    {
        get => _implicitFlowEnabled.GetValue(InlineErrors);
        set => _implicitFlowEnabled.SetValue(value);
    }

    private PropertyValue<string?> _implicitFlowRedirectURIs = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(ImplicitFlowRedirectURIs), "implicitFlowRedirectURIs");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("implicitFlowRedirectURIs")]
    public string? ImplicitFlowRedirectURIs
    {
        get => _implicitFlowRedirectURIs.GetValue(InlineErrors);
        set => _implicitFlowRedirectURIs.SetValue(value);
    }

    private PropertyValue<string?> _endpointUri = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(EndpointUri), "endpointUri");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("endpointUri")]
    public string? EndpointUri
    {
        get => _endpointUri.GetValue(InlineErrors);
        set => _endpointUri.SetValue(value);
    }

    private PropertyValue<bool?> _endpointSslVerification = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsEndpointSslVerification), "endpointSslVerification");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("endpointSslVerification")]
    public bool? IsEndpointSslVerification
    {
        get => _endpointSslVerification.GetValue(InlineErrors);
        set => _endpointSslVerification.SetValue(value);
    }

    private PropertyValue<bool?> _hasVerificationToken = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsHasVerificationToken), "hasVerificationToken");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [Obsolete("VerificationToken is an obsolete auth method - use it to turn it off (since 2021-09-02) (will be removed in a future version)")]
    [JsonPropertyName("hasVerificationToken")]
    public bool? IsHasVerificationToken
    {
        get => _hasVerificationToken.GetValue(InlineErrors);
        set => _hasVerificationToken.SetValue(value);
    }

    private PropertyValue<bool?> _hasPublicKeySignature = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsHasPublicKeySignature), "hasPublicKeySignature");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [Obsolete("Use appLevelAuth instead (since 2021-09-02) (will be removed in a future version)")]
    [JsonPropertyName("hasPublicKeySignature")]
    public bool? IsHasPublicKeySignature
    {
        get => _hasPublicKeySignature.GetValue(InlineErrors);
        set => _hasPublicKeySignature.SetValue(value);
    }

    private PropertyValue<bool?> _hasSigningKey = new PropertyValue<bool?>(nameof(ApplicationsForApplicationPatchRequest), nameof(IsHasSigningKey), "hasSigningKey");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [Obsolete("Use appLevelAuth instead (since 2021-09-02) (will be removed in a future version)")]
    [JsonPropertyName("hasSigningKey")]
    public bool? IsHasSigningKey
    {
        get => _hasSigningKey.GetValue(InlineErrors);
        set => _hasSigningKey.SetValue(value);
    }

    private PropertyValue<EndpointAppLevelAuthUpdateType?> _appLevelAuth = new PropertyValue<EndpointAppLevelAuthUpdateType?>(nameof(ApplicationsForApplicationPatchRequest), nameof(AppLevelAuth), "appLevelAuth");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("appLevelAuth")]
    public EndpointAppLevelAuthUpdateType? AppLevelAuth
    {
        get => _appLevelAuth.GetValue(InlineErrors);
        set => _appLevelAuth.SetValue(value);
    }

    private PropertyValue<string?> _sslKeystoreAuth = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(SslKeystoreAuth), "sslKeystoreAuth");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("sslKeystoreAuth")]
    public string? SslKeystoreAuth
    {
        get => _sslKeystoreAuth.GetValue(InlineErrors);
        set => _sslKeystoreAuth.SetValue(value);
    }

    private PropertyValue<string?> _basicAuthUsername = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(BasicAuthUsername), "basicAuthUsername");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("basicAuthUsername")]
    public string? BasicAuthUsername
    {
        get => _basicAuthUsername.GetValue(InlineErrors);
        set => _basicAuthUsername.SetValue(value);
    }

    private PropertyValue<string?> _basicAuthPassword = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(BasicAuthPassword), "basicAuthPassword");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("basicAuthPassword")]
    public string? BasicAuthPassword
    {
        get => _basicAuthPassword.GetValue(InlineErrors);
        set => _basicAuthPassword.SetValue(value);
    }

    private PropertyValue<string?> _bearerAuthToken = new PropertyValue<string?>(nameof(ApplicationsForApplicationPatchRequest), nameof(BearerAuthToken), "bearerAuthToken");
    
#if NET6_0_OR_GREATER
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
#endif
    [JsonPropertyName("bearerAuthToken")]
    public string? BearerAuthToken
    {
        get => _bearerAuthToken.GetValue(InlineErrors);
        set => _bearerAuthToken.SetValue(value);
    }

    public virtual void SetAccessPath(string parentChainPath, bool validateHasBeenSet)
    {
        _name.SetAccessPath(parentChainPath, validateHasBeenSet);
        _pictureAttachmentId.SetAccessPath(parentChainPath, validateHasBeenSet);
        _defaultExternalPicture.SetAccessPath(parentChainPath, validateHasBeenSet);
        _clientSecret.SetAccessPath(parentChainPath, validateHasBeenSet);
        _clientCredentialsFlowEnabled.SetAccessPath(parentChainPath, validateHasBeenSet);
        _codeFlowEnabled.SetAccessPath(parentChainPath, validateHasBeenSet);
        _codeFlowRedirectURIs.SetAccessPath(parentChainPath, validateHasBeenSet);
        _pkceRequired.SetAccessPath(parentChainPath, validateHasBeenSet);
        _implicitFlowEnabled.SetAccessPath(parentChainPath, validateHasBeenSet);
        _implicitFlowRedirectURIs.SetAccessPath(parentChainPath, validateHasBeenSet);
        _endpointUri.SetAccessPath(parentChainPath, validateHasBeenSet);
        _endpointSslVerification.SetAccessPath(parentChainPath, validateHasBeenSet);
        _hasVerificationToken.SetAccessPath(parentChainPath, validateHasBeenSet);
        _hasPublicKeySignature.SetAccessPath(parentChainPath, validateHasBeenSet);
        _hasSigningKey.SetAccessPath(parentChainPath, validateHasBeenSet);
        _appLevelAuth.SetAccessPath(parentChainPath, validateHasBeenSet);
        _sslKeystoreAuth.SetAccessPath(parentChainPath, validateHasBeenSet);
        _basicAuthUsername.SetAccessPath(parentChainPath, validateHasBeenSet);
        _basicAuthPassword.SetAccessPath(parentChainPath, validateHasBeenSet);
        _bearerAuthToken.SetAccessPath(parentChainPath, validateHasBeenSet);
    }
    
    /// <inheritdoc />
    [JsonPropertyName("$errors")]
    public List<ApiInlineError> InlineErrors { get; set; } = new();

}

