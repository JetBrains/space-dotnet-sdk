// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#nullable enable
#pragma warning disable CS1591
#pragma warning disable CS0108
#pragma warning disable 618

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel.DataAnnotations;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using JetBrains.Space.Common;
using JetBrains.Space.Common.Json.Serialization;
using JetBrains.Space.Common.Json.Serialization.Polymorphism;
using JetBrains.Space.Common.Types;

namespace JetBrains.Space.Client;

public partial class ApplicationClient : ISpaceClient
{
    private readonly Connection _connection;
    
    public ApplicationClient(Connection connection)
    {
        _connection = connection;
    }
    
    /// <summary>
    /// Creates a new application. Marketplace application cannot be installed using this endpoint.
    /// 
    /// To create a multi-org application (and connect application server to the current Space instance), pass `connectToSpace = true`. Learn more about multi-org applications in the [documentation](https://www.jetbrains.com/help/space/distribute-your-application.html).
    /// </summary>
    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>Create applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task<ESApp> CreateApplicationAsync(string name, string? description = null, string? pictureAttachmentId = null, string? defaultExternalPicture = null, string? email = null, string? clientId = null, string? clientSecret = null, bool? clientCredentialsFlowEnabled = true, bool? codeFlowEnabled = false, string? codeFlowRedirectURIs = null, bool? pkceRequired = null, bool? implicitFlowEnabled = false, string? implicitFlowRedirectURIs = null, string? endpointUri = null, bool? endpointSslVerification = null, EndpointAuthCreate? appLevelAuth = null, string? sslKeystoreAuth = null, bool? hasSigningKey = null, bool? hasPublicKeySignature = null, string? basicAuthUsername = null, string? basicAuthPassword = null, string? bearerAuthToken = null, bool? connectToSpace = false, string? state = null, Func<Partial<ESApp>, Partial<ESApp>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        queryParameters.Append("$fields", (partial != null ? partial(new Partial<ESApp>()) : Partial<ESApp>.Default()).ToString());
        
        return await _connection.RequestResourceAsync<ApplicationsPostRequest, ESApp>("POST", $"api/http/applications{queryParameters.ToQueryString()}", 
            new ApplicationsPostRequest
            { 
                Name = name,
                Description = description,
                PictureAttachmentId = pictureAttachmentId,
                DefaultExternalPicture = defaultExternalPicture,
                Email = email,
                ClientId = clientId,
                ClientSecret = clientSecret,
                IsClientCredentialsFlowEnabled = clientCredentialsFlowEnabled,
                IsCodeFlowEnabled = codeFlowEnabled,
                CodeFlowRedirectURIs = codeFlowRedirectURIs,
                IsPkceRequired = pkceRequired,
                IsImplicitFlowEnabled = implicitFlowEnabled,
                ImplicitFlowRedirectURIs = implicitFlowRedirectURIs,
                EndpointUri = endpointUri,
                IsEndpointSslVerification = endpointSslVerification,
                AppLevelAuth = appLevelAuth,
                SslKeystoreAuth = sslKeystoreAuth,
                IsHasSigningKey = hasSigningKey,
                IsHasPublicKeySignature = hasPublicKeySignature,
                BasicAuthUsername = basicAuthUsername,
                BasicAuthPassword = basicAuthPassword,
                BearerAuthToken = bearerAuthToken,
                IsConnectToSpace = connectToSpace,
                State = state,
            }, requestHeaders: null, functionName: "CreateApplication", cancellationToken: cancellationToken);
    }
    

    /// <summary>
    /// Removes the application that has previously failed to respond with code 200 to `ApplicationUninstalledPayload` request, without sending additional `ApplicationUninstalledPayload` requests. The application is archived and its access terminated.
    /// </summary>
    /// <param name="application">
    /// Identifier of the application to force-remove
    /// </param>
    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>Delete applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task ForceRemoveApplicationAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        
        await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/force-remove{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "ForceRemoveApplication", cancellationToken: cancellationToken);
    }
    

    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>Update applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task RestoreApplicationAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        
        await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/restore{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "RestoreApplication", cancellationToken: cancellationToken);
    }
    

    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>View applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task<Batch<ESApp>> GetAllApplicationsAsync(string? skip = null, int? top = 100, string? name = null, List<ProfileIdentifier>? owner = null, bool? withArchived = false, bool? withManaged = true, AppsOrdering? ordering = null, Func<Partial<Batch<ESApp>>, Partial<Batch<ESApp>>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        if (skip != null) queryParameters.Append("$skip", skip);
        if (top != null) queryParameters.Append("$top", top?.ToString());
        if (name != null) queryParameters.Append("name", name);
        if (owner != null) queryParameters.Append("owner", owner.Select(it => it.ToString()));
        if (withArchived != null) queryParameters.Append("withArchived", withArchived?.ToString("l"));
        if (withManaged != null) queryParameters.Append("withManaged", withManaged?.ToString("l"));
        queryParameters.Append("ordering", ordering.ToEnumString());
        queryParameters.Append("$fields", (partial != null ? partial(new Partial<Batch<ESApp>>()) : Partial<Batch<ESApp>>.Default()).ToString());
        
        return await _connection.RequestResourceAsync<Batch<ESApp>>("GET", $"api/http/applications/paged{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllApplications", cancellationToken: cancellationToken);
    }
    
    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>View applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public IAsyncEnumerable<ESApp> GetAllApplicationsAsyncEnumerable(string? skip = null, int? top = 100, string? name = null, List<ProfileIdentifier>? owner = null, bool? withArchived = false, bool? withManaged = true, AppsOrdering? ordering = null, Func<Partial<ESApp>, Partial<ESApp>>? partial = null, CancellationToken cancellationToken = default)
        => BatchEnumerator.AllItems((batchSkip, batchCancellationToken) => GetAllApplicationsAsync(top: top, name: name, owner: owner, withArchived: withArchived, withManaged: withManaged, ordering: ordering, cancellationToken: cancellationToken, skip: batchSkip, partial: builder => Partial<Batch<ESApp>>.Default().WithNext().WithTotalCount().WithData(partial != null ? partial : _ => Partial<ESApp>.Default())), skip, cancellationToken);

    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>View applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task<ESApp> GetApplicationAsync(ApplicationIdentifier application, Func<Partial<ESApp>, Partial<ESApp>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        queryParameters.Append("$fields", (partial != null ? partial(new Partial<ESApp>()) : Partial<ESApp>.Default()).ToString());
        
        return await _connection.RequestResourceAsync<ESApp>("GET", $"api/http/applications/{application}{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetApplication", cancellationToken: cancellationToken);
    }
    

    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>View application secrets</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task<string> BearerTokenAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        
        return await _connection.RequestResourceAsync<string>("GET", $"api/http/applications/{application}/bearer-token{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "BearerToken", cancellationToken: cancellationToken);
    }
    

    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>View applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task<AccessRecord> GetLastClientCredentialsAccessInfoAsync(ApplicationIdentifier application, Func<Partial<AccessRecord>, Partial<AccessRecord>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        queryParameters.Append("$fields", (partial != null ? partial(new Partial<AccessRecord>()) : Partial<AccessRecord>.Default()).ToString());
        
        return await _connection.RequestResourceAsync<AccessRecord>("GET", $"api/http/applications/{application}/last-client-credentials-access{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetLastClientCredentialsAccessInfo", cancellationToken: cancellationToken);
    }
    

    /// <summary>
    /// Returns list of public keys in JWKS format. If message signature is successfully verified with any of the returned public keys, the message can be considered authentic.
    /// </summary>
    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>View applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task<string> PublicKeysAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        
        return await _connection.RequestResourceAsync<string>("GET", $"api/http/applications/{application}/public-keys{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "PublicKeys", cancellationToken: cancellationToken);
    }
    

    /// <summary>
    /// Set UI extensions supported by the calling application in specified context. Only the application itself can set its extensions.
    /// </summary>
    public async Task SetUiExtensionsAsync(PermissionContextIdentifier contextIdentifier, List<AppUiExtensionIn> extensions, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        
        await _connection.RequestResourceAsync("PATCH", $"api/http/applications/ui-extensions{queryParameters.ToQueryString()}", 
            new ApplicationsUiExtensionsPatchRequest
            { 
                ContextIdentifier = contextIdentifier,
                Extensions = extensions,
            }, requestHeaders: null, functionName: "SetUiExtensions", cancellationToken: cancellationToken);
    }
    

    /// <summary>
    /// Update existing application. Multi-org applications (created with the parameter `connectToSpace = true` or installed from JetBrains Marketplace) can only be updated by the application itself. Learn more about multi-org applications in the [documentation](https://www.jetbrains.com/help/space/distribute-your-application.html).
    /// </summary>
    /// <param name="application">
    /// The application that needs to be updated
    /// </param>
    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>Update applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task<ESApp> UpdateApplicationAsync(ApplicationIdentifier application, string? name = null, string? description = null, string? clientSecret = null, bool? clientCredentialsFlowEnabled = null, bool? codeFlowEnabled = null, bool? pkceRequired = null, bool? implicitFlowEnabled = null, bool? endpointSslVerification = null, bool? hasVerificationToken = null, bool? hasPublicKeySignature = null, bool? hasSigningKey = null, EndpointAppLevelAuthUpdateType? appLevelAuth = null, string? basicAuthUsername = null, string? basicAuthPassword = null, string? bearerAuthToken = null, string? pictureAttachmentId = null, string? defaultExternalPicture = null, string? codeFlowRedirectURIs = null, string? implicitFlowRedirectURIs = null, string? endpointUri = null, string? sslKeystoreAuth = null, Func<Partial<ESApp>, Partial<ESApp>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        queryParameters.Append("$fields", (partial != null ? partial(new Partial<ESApp>()) : Partial<ESApp>.Default()).ToString());
        
        return await _connection.RequestResourceAsync<ApplicationsForApplicationPatchRequest, ESApp>("PATCH", $"api/http/applications/{application}{queryParameters.ToQueryString()}", 
            new ApplicationsForApplicationPatchRequest
            { 
                Name = name,
                Description = description,
                PictureAttachmentId = pictureAttachmentId,
                DefaultExternalPicture = defaultExternalPicture,
                ClientSecret = clientSecret,
                IsClientCredentialsFlowEnabled = clientCredentialsFlowEnabled,
                IsCodeFlowEnabled = codeFlowEnabled,
                CodeFlowRedirectURIs = codeFlowRedirectURIs,
                IsPkceRequired = pkceRequired,
                IsImplicitFlowEnabled = implicitFlowEnabled,
                ImplicitFlowRedirectURIs = implicitFlowRedirectURIs,
                EndpointUri = endpointUri,
                IsEndpointSslVerification = endpointSslVerification,
                IsHasVerificationToken = hasVerificationToken,
                IsHasPublicKeySignature = hasPublicKeySignature,
                IsHasSigningKey = hasSigningKey,
                AppLevelAuth = appLevelAuth,
                SslKeystoreAuth = sslKeystoreAuth,
                BasicAuthUsername = basicAuthUsername,
                BasicAuthPassword = basicAuthPassword,
                BearerAuthToken = bearerAuthToken,
            }, requestHeaders: null, functionName: "UpdateApplication", cancellationToken: cancellationToken);
    }
    

    /// <summary>
    /// Removes specified application. If the application is connected (installed from Marketplace or through an install link), Space sends `ApplicationUninstalledPayload` to the application's server. The application is only actually deleted when the application server responds or when the `ApplicationUninstalledPayload` request times out multiple times.
    /// 
    /// This API method does not wait until the `ApplicationUninstalledPayload` request is finished and instead returns immediately. Consequently, the application may still be active right after this API method call.
    /// 
    /// If sending `ApplicationUninstalledPayload` has failed at least one time, a user may choose to force-remove the application. In this case the access for the application is terminated and it can no longer make requests. 
    /// </summary>
    /// <param name="application">
    /// Identifier of the application to remove
    /// </param>
    /// <remarks>
    /// Required permissions:
    /// <list type="bullet">
    /// <item>
    /// <term>Delete applications</term>
    /// </item>
    /// </list>
    /// </remarks>
    public async Task DeleteApplicationAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
    {
        var queryParameters = new NameValueCollection();
        
        await _connection.RequestResourceAsync("DELETE", $"api/http/applications/{application}{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "DeleteApplication", cancellationToken: cancellationToken);
    }
    

    public AuthorizationClient Authorizations => new AuthorizationClient(_connection);
    
    public partial class AuthorizationClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public AuthorizationClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <summary>
        /// List applications authorized in specified context
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<List<ESApp>> GetApplicationsAuthorizedInContextAsync(PermissionContextIdentifier contextIdentifier, Func<Partial<ESApp>, Partial<ESApp>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("contextIdentifier", contextIdentifier.ToString());
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<ESApp>()) : Partial<ESApp>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<List<ESApp>>("GET", $"api/http/applications/authorizations/authorized-applications{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetApplicationsAuthorizedInContext", cancellationToken: cancellationToken);
        }
        
    
    }

    public partial class AuthorizationClient : ISpaceClient
    {
        /// <summary>
        /// List authorized contexts of an application
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<List<PermissionContextApi>> GetAllAuthorizedContextsAsync(ApplicationIdentifier application, Func<Partial<PermissionContextApi>, Partial<PermissionContextApi>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<PermissionContextApi>()) : Partial<PermissionContextApi>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<List<PermissionContextApi>>("GET", $"api/http/applications/{application}/authorizations/authorized-contexts{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllAuthorizedContexts", cancellationToken: cancellationToken);
        }
        
    
        public AuthorizedRightClient AuthorizedRights => new AuthorizedRightClient(_connection);
        
        public partial class AuthorizedRightClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public AuthorizedRightClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <summary>
            /// List authorized rights of an application in specified context
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>View applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<List<RightDTO>> GetAllAuthorizedRightsAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, Func<Partial<RightDTO>, Partial<RightDTO>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("contextIdentifier", contextIdentifier.ToString());
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<RightDTO>()) : Partial<RightDTO>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<List<RightDTO>>("GET", $"api/http/applications/{application}/authorizations/authorized-rights{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllAuthorizedRights", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Generic method for editing authorized right status in given context.
            /// </summary>
            public async Task UpdateAuthorizedRightAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, List<RightUpdateDTO> updates, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/authorizations/authorized-rights{queryParameters.ToQueryString()}", 
                    new ApplicationsForApplicationAuthorizationsAuthorizedRightsPatchRequest
                    { 
                        ContextIdentifier = contextIdentifier,
                        Updates = updates,
                    }, requestHeaders: null, functionName: "UpdateAuthorizedRight", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Request rights for an application in specified context
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task RequestRightsAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, List<PermissionIdentifier> rightCodes, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/authorizations/authorized-rights/request-rights{queryParameters.ToQueryString()}", 
                    new ApplicationsForApplicationAuthorizationsAuthorizedRightsRequestRightsPatchRequest
                    { 
                        ContextIdentifier = contextIdentifier,
                        RightCodes = rightCodes,
                    }, requestHeaders: null, functionName: "RequestRights", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Remove application authorization in specified context
            /// </summary>
            public async Task DeleteAuthorizedRightAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("contextIdentifier", contextIdentifier.ToString());
                
                await _connection.RequestResourceAsync("DELETE", $"api/http/applications/{application}/authorizations/authorized-rights{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "DeleteAuthorizedRight", cancellationToken: cancellationToken);
            }
            
        
        }
    
        public RequiredRightClient RequiredRights => new RequiredRightClient(_connection);
        
        public partial class RequiredRightClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public RequiredRightClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <summary>
            /// List required rights for an application
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>View applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<List<RightDTO>> GetAllRequiredRightsAsync(ApplicationIdentifier application, Func<Partial<RightDTO>, Partial<RightDTO>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<RightDTO>()) : Partial<RightDTO>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<List<RightDTO>>("GET", $"api/http/applications/{application}/authorizations/required-rights{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllRequiredRights", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Update list of required rights for an application
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task UpdateRequiredRightAsync(ApplicationIdentifier application, List<PermissionIdentifier> rightCodesToAdd, List<PermissionIdentifier> rightCodesToRemove, bool requestRightsInAuthorizedContexts, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/authorizations/required-rights{queryParameters.ToQueryString()}", 
                    new ApplicationsForApplicationAuthorizationsRequiredRightsPatchRequest
                    { 
                        RightCodesToAdd = rightCodesToAdd,
                        RightCodesToRemove = rightCodesToRemove,
                        IsRequestRightsInAuthorizedContexts = requestRightsInAuthorizedContexts,
                    }, requestHeaders: null, functionName: "UpdateRequiredRight", cancellationToken: cancellationToken);
            }
            
        
        }
    
    }

    public UnfurlClient Unfurls => new UnfurlClient(_connection);
    
    public partial class UnfurlClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public UnfurlClient(Connection connection)
        {
            _connection = connection;
        }
        
        public DomainClient Domains => new DomainClient(_connection);
        
        public partial class DomainClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public DomainClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <summary>
            /// Update list of domains for unfurling by the application. Method is to be called by the application providing unfurls.
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task UpdateUnfurledDomainsAsync(List<string> domains, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("PATCH", $"api/http/applications/unfurls/domains{queryParameters.ToQueryString()}", 
                    new ApplicationsUnfurlsDomainsPatchRequest
                    { 
                        Domains = domains,
                    }, requestHeaders: null, functionName: "UpdateUnfurledDomains", cancellationToken: cancellationToken);
            }
            
        
        }
    
        public PatternClient Patterns => new PatternClient(_connection);
        
        public partial class PatternClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public PatternClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <summary>
            /// Update list of external ID prefixes for unfurling by the application. Method is to be called by the application providing unfurls.
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task UpdateUnfurledPatternsAsync(List<ApplicationUnfurlPatternRequest> patterns, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("PATCH", $"api/http/applications/unfurls/patterns{queryParameters.ToQueryString()}", 
                    new ApplicationsUnfurlsPatternsPatchRequest
                    { 
                        Patterns = patterns,
                    }, requestHeaders: null, functionName: "UpdateUnfurledPatterns", cancellationToken: cancellationToken);
            }
            
        
        }
    
        public QueueClient Queue => new QueueClient(_connection);
        
        public partial class QueueClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public QueueClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <summary>
            /// Provide Space with unfurls content. Method is to be called by the application providing unfurls.
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Provide external unfurls as attachments</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<List<PostUnfurlContentResult>> PostUnfurlsContentAsync(List<ApplicationUnfurl> unfurls, Func<Partial<PostUnfurlContentResult>, Partial<PostUnfurlContentResult>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<PostUnfurlContentResult>()) : Partial<PostUnfurlContentResult>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<ApplicationsUnfurlsQueueContentPostRequest, List<PostUnfurlContentResult>>("POST", $"api/http/applications/unfurls/queue/content{queryParameters.ToQueryString()}", 
                    new ApplicationsUnfurlsQueueContentPostRequest
                    { 
                        Unfurls = unfurls,
                    }, requestHeaders: null, functionName: "PostUnfurlsContent", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Request user to authenticate in external system to provide unfurls from it. Method is to be called by the application providing unfurls.
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Provide external unfurls as attachments</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task RequestExternalSystemAuthenticationAsync(string queueItemId, ApplicationUnfurlContentMessage message, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("POST", $"api/http/applications/unfurls/queue/request-external-auth{queryParameters.ToQueryString()}", 
                    new ApplicationsUnfurlsQueueRequestExternalAuthPostRequest
                    { 
                        QueueItemId = queueItemId,
                        Message = message,
                    }, requestHeaders: null, functionName: "RequestExternalSystemAuthentication", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Clear all external system authentication requests for the specified user. Method is to be called by the application providing unfurls.
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Provide external unfurls as attachments</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task ClearExternalSystemAuthenticationRequestsAsync(ProfileIdentifier userId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("POST", $"api/http/applications/unfurls/queue/reset-external-auth-requests{queryParameters.ToQueryString()}", 
                    new ApplicationsUnfurlsQueueResetExternalAuthRequestsPostRequest
                    { 
                        UserId = userId,
                    }, requestHeaders: null, functionName: "ClearExternalSystemAuthenticationRequests", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Get links for unfurling by the application. Method is to be called by the application providing unfurls.
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Provide external unfurls as attachments</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<List<ApplicationUnfurlQueueItem>> GetUnfurlQueueItemsAsync(int batchSize, long? fromEtag = null, Func<Partial<ApplicationUnfurlQueueItem>, Partial<ApplicationUnfurlQueueItem>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                if (fromEtag != null) queryParameters.Append("fromEtag", fromEtag?.ToString());
                queryParameters.Append("batchSize", batchSize.ToString());
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<ApplicationUnfurlQueueItem>()) : Partial<ApplicationUnfurlQueueItem>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<List<ApplicationUnfurlQueueItem>>("GET", $"api/http/applications/unfurls/queue{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetUnfurlQueueItems", cancellationToken: cancellationToken);
            }
            
        
        }
    
    }

    public ClientSecretClient ClientSecret => new ClientSecretClient(_connection);
    
    public partial class ClientSecretClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public ClientSecretClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task RegenerateAppSecretAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/client-secret/regenerate{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "RegenerateAppSecret", cancellationToken: cancellationToken);
        }
        
    
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View application secrets</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<string> GetClientSecretAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            return await _connection.RequestResourceAsync<string>("GET", $"api/http/applications/{application}/client-secret{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetClientSecret", cancellationToken: cancellationToken);
        }
        
    
    }

    public PermanentTokenClient PermanentTokens => new PermanentTokenClient(_connection);
    
    public partial class PermanentTokenClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public PermanentTokenClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <summary>
        /// Create a permanent token for the given application that can be used to access the current organization
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<Pair<ESApplicationPermanentToken, string>> CreatePermanentTokenAsync(ApplicationIdentifier application, string name, PermissionScope scope, DateTime? expires = null, Func<Partial<Pair<ESApplicationPermanentToken, string>>, Partial<Pair<ESApplicationPermanentToken, string>>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<Pair<ESApplicationPermanentToken, string>>()) : Partial<Pair<ESApplicationPermanentToken, string>>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<ApplicationsForApplicationPermanentTokensPostRequest, Pair<ESApplicationPermanentToken, string>>("POST", $"api/http/applications/{application}/permanent-tokens{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationPermanentTokensPostRequest
                { 
                    Name = name,
                    Scope = scope,
                    Expires = expires,
                }, requestHeaders: null, functionName: "CreatePermanentToken", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Get permanent tokens used to access the current organization by the given application
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View application secrets</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<Batch<ESApplicationPermanentToken>> GetAllPermanentTokensAsync(ApplicationIdentifier application, string? skip = null, int? top = 100, Func<Partial<Batch<ESApplicationPermanentToken>>, Partial<Batch<ESApplicationPermanentToken>>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            if (skip != null) queryParameters.Append("$skip", skip);
            if (top != null) queryParameters.Append("$top", top?.ToString());
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<Batch<ESApplicationPermanentToken>>()) : Partial<Batch<ESApplicationPermanentToken>>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<Batch<ESApplicationPermanentToken>>("GET", $"api/http/applications/{application}/permanent-tokens{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllPermanentTokens", cancellationToken: cancellationToken);
        }
        
        /// <summary>
        /// Get permanent tokens used to access the current organization by the given application
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View application secrets</term>
        /// </item>
        /// </list>
        /// </remarks>
        public IAsyncEnumerable<ESApplicationPermanentToken> GetAllPermanentTokensAsyncEnumerable(ApplicationIdentifier application, string? skip = null, int? top = 100, Func<Partial<ESApplicationPermanentToken>, Partial<ESApplicationPermanentToken>>? partial = null, CancellationToken cancellationToken = default)
            => BatchEnumerator.AllItems((batchSkip, batchCancellationToken) => GetAllPermanentTokensAsync(application: application, top: top, cancellationToken: cancellationToken, skip: batchSkip, partial: builder => Partial<Batch<ESApplicationPermanentToken>>.Default().WithNext().WithTotalCount().WithData(partial != null ? partial : _ => Partial<ESApplicationPermanentToken>.Default())), skip, cancellationToken);
    
        /// <summary>
        /// Update an existing personal token used to access the current organization. The permanent token's name and/or scope can be updated.
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task UpdatePermanentTokenAsync(ApplicationIdentifier application, string tokenId, string? name = null, PermissionScope? scope = null, DateTime? expires = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/permanent-tokens/{tokenId}{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationPermanentTokensForTokenIdPatchRequest
                { 
                    Name = name,
                    Scope = scope,
                    Expires = expires,
                }, requestHeaders: null, functionName: "UpdatePermanentToken", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Delete a personal token used to access the current organization
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task DeletePermanentTokenAsync(ApplicationIdentifier application, string tokenId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("DELETE", $"api/http/applications/{application}/permanent-tokens/{tokenId}{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "DeletePermanentToken", cancellationToken: cancellationToken);
        }
        
    
        public CurrentClient Current => new CurrentClient(_connection);
        
        public partial class CurrentClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public CurrentClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <summary>
            /// Delete personal token of the given application
            /// </summary>
            public async Task DeleteCurrentPermanentTokenAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("DELETE", $"api/http/applications/{application}/permanent-tokens/current{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "DeleteCurrentPermanentToken", cancellationToken: cancellationToken);
            }
            
        
        }
    
    }

    public SigningKeyClient SigningKey => new SigningKeyClient(_connection);
    
    public partial class SigningKeyClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public SigningKeyClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task RegenerateSigningKeyAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/signing-key/regenerate{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "RegenerateSigningKey", cancellationToken: cancellationToken);
        }
        
    
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View application secrets</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<string> GetSigningKeyAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            return await _connection.RequestResourceAsync<string>("GET", $"api/http/applications/{application}/signing-key{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetSigningKey", cancellationToken: cancellationToken);
        }
        
    
    }

    public SshKeyClient SshKeys => new SshKeyClient(_connection);
    
    public partial class SshKeyClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public SshKeyClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task AddSshKeyAsync(ApplicationIdentifier application, string publicKey, string comment, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/ssh-keys{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationSshKeysPostRequest
                { 
                    PublicKey = publicKey,
                    Comment = comment,
                }, requestHeaders: null, functionName: "AddSshKey", cancellationToken: cancellationToken);
        }
        
    
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<List<SshKeyData>> GetSshKeysAsync(ApplicationIdentifier application, Func<Partial<SshKeyData>, Partial<SshKeyData>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<SshKeyData>()) : Partial<SshKeyData>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<List<SshKeyData>>("GET", $"api/http/applications/{application}/ssh-keys{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetSshKeys", cancellationToken: cancellationToken);
        }
        
    
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task DeleteSshKeyAsync(ApplicationIdentifier application, string fingerprint, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("DELETE", $"api/http/applications/{application}/ssh-keys/{fingerprint}{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "DeleteSshKey", cancellationToken: cancellationToken);
        }
        
    
    }

    public UiExtensionClient UiExtensions => new UiExtensionClient(_connection);
    
    public partial class UiExtensionClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public UiExtensionClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <summary>
        /// Get UI extensions supported by the application in specified context. Omit contextIdentifier to get UI extensions in all contexts
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<List<AppUiExtensionApi>> GetUiExtensionsAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, Func<Partial<AppUiExtensionApi>, Partial<AppUiExtensionApi>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("contextIdentifier", contextIdentifier.ToString());
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<AppUiExtensionApi>()) : Partial<AppUiExtensionApi>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<List<AppUiExtensionApi>>("GET", $"api/http/applications/{application}/ui-extensions{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetUiExtensions", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Disable application UI for everybody in specified context. Requires Superadmin right for global context, AdminProject for project context, AdminChannel for channel context. Users will still be able to enable application UI individually.
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// <item>
        /// <term>Grant permissions to other members</term>
        /// </item>
        /// <item>
        /// <term>Manage project permission scheme</term>
        /// </item>
        /// <item>
        /// <term>Manage channels</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task DisableApplicationUiAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/ui-extensions/disable-for-everybody{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationUiExtensionsDisableForEverybodyPatchRequest
                { 
                    ContextIdentifier = contextIdentifier,
                }, requestHeaders: null, functionName: "DisableApplicationUi", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Disable application UI in specified context for the current user
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task DisableApplicationUiForMeAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/ui-extensions/disable-for-me{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationUiExtensionsDisableForMePatchRequest
                { 
                    ContextIdentifier = contextIdentifier,
                }, requestHeaders: null, functionName: "DisableApplicationUiForMe", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Enable application UI for everybody in specified context. Requires Superadmin right for global context, AdminProject for project context, AdminChannel for channel context. Users will still be able to disable application UI individually.
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// <item>
        /// <term>Grant permissions to other members</term>
        /// </item>
        /// <item>
        /// <term>Manage project permission scheme</term>
        /// </item>
        /// <item>
        /// <term>Manage channels</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task EnableApplicationUiAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/ui-extensions/enable-for-everybody{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationUiExtensionsEnableForEverybodyPatchRequest
                { 
                    ContextIdentifier = contextIdentifier,
                }, requestHeaders: null, functionName: "EnableApplicationUi", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Enable application UI in specified context for the current user
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task EnableApplicationUiForMeAsync(ApplicationIdentifier application, PermissionContextIdentifier contextIdentifier, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/ui-extensions/enable-for-me{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationUiExtensionsEnableForMePatchRequest
                { 
                    ContextIdentifier = contextIdentifier,
                }, requestHeaders: null, functionName: "EnableApplicationUiForMe", cancellationToken: cancellationToken);
        }
        
    
    }

    public UnfurlDomainClient UnfurlDomains => new UnfurlDomainClient(_connection);
    
    public partial class UnfurlDomainClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public UnfurlDomainClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <summary>
        /// Authorize domains for unfurling by the application
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Authorize domains and patterns for app-powered previews</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task AuthorizeUnfurledDomainsAsync(ApplicationIdentifier application, List<string> domains, bool approve, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/unfurl-domains/authorize{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationUnfurlDomainsAuthorizePostRequest
                { 
                    Domains = domains,
                    IsApprove = approve,
                }, requestHeaders: null, functionName: "AuthorizeUnfurledDomains", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// List domains for unfurling by the application
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<List<ApplicationUnfurlDomain>> GetAllUnfurlDomainsAsync(ApplicationIdentifier application, Func<Partial<ApplicationUnfurlDomain>, Partial<ApplicationUnfurlDomain>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<ApplicationUnfurlDomain>()) : Partial<ApplicationUnfurlDomain>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<List<ApplicationUnfurlDomain>>("GET", $"api/http/applications/{application}/unfurl-domains{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllUnfurlDomains", cancellationToken: cancellationToken);
        }
        
    
    }

    public UnfurlPatternClient UnfurlPatterns => new UnfurlPatternClient(_connection);
    
    public partial class UnfurlPatternClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public UnfurlPatternClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <summary>
        /// Authorize patterns for unfurling by the application
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Authorize domains and patterns for app-powered previews</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task AuthorizeUnfurledPatternsAsync(ApplicationIdentifier application, List<string> patterns, bool approve, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/unfurl-patterns/authorize{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationUnfurlPatternsAuthorizePostRequest
                { 
                    Patterns = patterns,
                    IsApprove = approve,
                }, requestHeaders: null, functionName: "AuthorizeUnfurledPatterns", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// List patterns for unfurling by the application
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<List<ApplicationUnfurlPattern>> GetAllUnfurlPatternsAsync(ApplicationIdentifier application, Func<Partial<ApplicationUnfurlPattern>, Partial<ApplicationUnfurlPattern>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<ApplicationUnfurlPattern>()) : Partial<ApplicationUnfurlPattern>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<List<ApplicationUnfurlPattern>>("GET", $"api/http/applications/{application}/unfurl-patterns{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllUnfurlPatterns", cancellationToken: cancellationToken);
        }
        
    
    }

    public VerificationTokenClient VerificationToken => new VerificationTokenClient(_connection);
    
    public partial class VerificationTokenClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public VerificationTokenClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task RegenerateVerificationTokenAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/verification-token/regenerate{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "RegenerateVerificationToken", cancellationToken: cancellationToken);
        }
        
    
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View application secrets</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<string> GetVerificationTokenAsync(ApplicationIdentifier application, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            return await _connection.RequestResourceAsync<string>("GET", $"api/http/applications/{application}/verification-token{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetVerificationToken", cancellationToken: cancellationToken);
        }
        
    
    }

    public WebhookClient Webhooks => new WebhookClient(_connection);
    
    public partial class WebhookClient : ISpaceClient
    {
        private readonly Connection _connection;
        
        public WebhookClient(Connection connection)
        {
            _connection = connection;
        }
        
        /// <summary>
        /// Create application webhook
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<WebhookRecord> CreateWebhookAsync(ApplicationIdentifier application, string name, List<int> acceptedHttpResponseCodes, bool enabled = true, bool doRetries = true, string? description = null, EndpointCreateDTO? endpoint = null, EndpointAuthCreateDTO? endpointAuth = null, string? payloadFields = null, Func<Partial<WebhookRecord>, Partial<WebhookRecord>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<WebhookRecord>()) : Partial<WebhookRecord>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<ApplicationsForApplicationWebhooksPostRequest, WebhookRecord>("POST", $"api/http/applications/{application}/webhooks{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationWebhooksPostRequest
                { 
                    Name = name,
                    Description = description,
                    Endpoint = endpoint,
                    EndpointAuth = endpointAuth,
                    IsEnabled = enabled,
                    AcceptedHttpResponseCodes = acceptedHttpResponseCodes,
                    IsDoRetries = doRetries,
                    PayloadFields = payloadFields,
                }, requestHeaders: null, functionName: "CreateWebhook", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Restore archived application webhook
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task PostWebhookAsync(ApplicationIdentifier application, string webhookId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/webhooks/{webhookId}{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "PostWebhook", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Get application webhooks
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<Batch<FullWebhookDTO>> GetAllWebhooksAsync(ApplicationIdentifier application, bool withArchived = false, string query = "", string? skip = null, int? top = 100, Func<Partial<Batch<FullWebhookDTO>>, Partial<Batch<FullWebhookDTO>>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            queryParameters.Append("withArchived", withArchived.ToString("l"));
            queryParameters.Append("query", query);
            if (skip != null) queryParameters.Append("$skip", skip);
            if (top != null) queryParameters.Append("$top", top?.ToString());
            queryParameters.Append("$fields", (partial != null ? partial(new Partial<Batch<FullWebhookDTO>>()) : Partial<Batch<FullWebhookDTO>>.Default()).ToString());
            
            return await _connection.RequestResourceAsync<Batch<FullWebhookDTO>>("GET", $"api/http/applications/{application}/webhooks{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllWebhooks", cancellationToken: cancellationToken);
        }
        
        /// <summary>
        /// Get application webhooks
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public IAsyncEnumerable<FullWebhookDTO> GetAllWebhooksAsyncEnumerable(ApplicationIdentifier application, bool withArchived = false, string query = "", string? skip = null, int? top = 100, Func<Partial<FullWebhookDTO>, Partial<FullWebhookDTO>>? partial = null, CancellationToken cancellationToken = default)
            => BatchEnumerator.AllItems((batchSkip, batchCancellationToken) => GetAllWebhooksAsync(application: application, withArchived: withArchived, query: query, top: top, cancellationToken: cancellationToken, skip: batchSkip, partial: builder => Partial<Batch<FullWebhookDTO>>.Default().WithNext().WithTotalCount().WithData(partial != null ? partial : _ => Partial<FullWebhookDTO>.Default())), skip, cancellationToken);
    
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>View application secrets</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task<string> BearerTokenAsync(ApplicationIdentifier application, string webhookId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            return await _connection.RequestResourceAsync<string>("GET", $"api/http/applications/{application}/webhooks/{webhookId}/bearer-token{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "BearerToken", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Update application webhook
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task UpdateWebhookAsync(ApplicationIdentifier application, string webhookId, List<int> acceptedHttpResponseCodes, string? name = null, bool? enabled = null, bool? doRetries = null, string? description = null, ExternalEndpointUpdateDTO? endpoint = null, EndpointAuthUpdateDTO? endpointAuth = null, string? payloadFields = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("PATCH", $"api/http/applications/{application}/webhooks/{webhookId}{queryParameters.ToQueryString()}", 
                new ApplicationsForApplicationWebhooksForWebhookIdPatchRequest
                { 
                    Name = name,
                    Description = description,
                    IsEnabled = enabled,
                    Endpoint = endpoint,
                    EndpointAuth = endpointAuth,
                    AcceptedHttpResponseCodes = acceptedHttpResponseCodes,
                    IsDoRetries = doRetries,
                    PayloadFields = payloadFields,
                }, requestHeaders: null, functionName: "UpdateWebhook", cancellationToken: cancellationToken);
        }
        
    
        /// <summary>
        /// Archive application webhook
        /// </summary>
        /// <remarks>
        /// Required permissions:
        /// <list type="bullet">
        /// <item>
        /// <term>Update applications</term>
        /// </item>
        /// </list>
        /// </remarks>
        public async Task DeleteWebhookAsync(ApplicationIdentifier application, string webhookId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
        {
            var queryParameters = new NameValueCollection();
            
            await _connection.RequestResourceAsync("DELETE", $"api/http/applications/{application}/webhooks/{webhookId}{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "DeleteWebhook", cancellationToken: cancellationToken);
        }
        
    
        public CustomHeaderClient CustomHeaders => new CustomHeaderClient(_connection);
        
        public partial class CustomHeaderClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public CustomHeaderClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task PostCustomHeaderAsync(ApplicationIdentifier application, string webhookId, List<CustomHttpHeaderDTO> headers, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/webhooks/{webhookId}/custom-headers{queryParameters.ToQueryString()}", 
                    new ApplicationsForApplicationWebhooksForWebhookIdCustomHeadersPostRequest
                    { 
                        Headers = headers,
                    }, requestHeaders: null, functionName: "PostCustomHeader", cancellationToken: cancellationToken);
            }
            
        
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>View application secrets</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<List<CustomHttpHeaderDTO>> GetCustomHeaderAsync(ApplicationIdentifier application, string webhookId, Func<Partial<CustomHttpHeaderDTO>, Partial<CustomHttpHeaderDTO>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<CustomHttpHeaderDTO>()) : Partial<CustomHttpHeaderDTO>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<List<CustomHttpHeaderDTO>>("GET", $"api/http/applications/{application}/webhooks/{webhookId}/custom-headers{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetCustomHeader", cancellationToken: cancellationToken);
            }
            
        
        }
    
        public SigningKeyClient SigningKey => new SigningKeyClient(_connection);
        
        public partial class SigningKeyClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public SigningKeyClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task RegenerateAsync(ApplicationIdentifier application, string webhookId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/webhooks/{webhookId}/signing-key/regenerate{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "Regenerate", cancellationToken: cancellationToken);
            }
            
        
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>View application secrets</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<string> GetSigningKeyAsync(ApplicationIdentifier application, string webhookId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                return await _connection.RequestResourceAsync<string>("GET", $"api/http/applications/{application}/webhooks/{webhookId}/signing-key{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetSigningKey", cancellationToken: cancellationToken);
            }
            
        
        }
    
        public SubscriptionClient Subscriptions => new SubscriptionClient(_connection);
        
        public partial class SubscriptionClient : ISpaceClient
        {
            private readonly Connection _connection;
            
            public SubscriptionClient(Connection connection)
            {
                _connection = connection;
            }
            
            /// <summary>
            /// Add webhook subscription
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<SubscriptionDTO> CreateSubscriptionAsync(ApplicationIdentifier application, string webhookId, string name, CustomGenericSubscriptionIn subscription, Func<Partial<SubscriptionDTO>, Partial<SubscriptionDTO>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<SubscriptionDTO>()) : Partial<SubscriptionDTO>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<ApplicationsForApplicationWebhooksForWebhookIdSubscriptionsPostRequest, SubscriptionDTO>("POST", $"api/http/applications/{application}/webhooks/{webhookId}/subscriptions{queryParameters.ToQueryString()}", 
                    new ApplicationsForApplicationWebhooksForWebhookIdSubscriptionsPostRequest
                    { 
                        Name = name,
                        Subscription = subscription,
                    }, requestHeaders: null, functionName: "CreateSubscription", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Ensures that all permissions required for this subscription are requested in the corresponding permission role
            /// </summary>
            public async Task RequestMissingRightsAsync(ApplicationIdentifier application, string webhookId, string subscriptionId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("POST", $"api/http/applications/{application}/webhooks/{webhookId}/subscriptions/{subscriptionId}/request-missing-rights{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "RequestMissingRights", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Get webhook subscriptions
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>View applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<List<SubscriptionDTO>> GetAllSubscriptionsAsync(ApplicationIdentifier application, string webhookId, Func<Partial<SubscriptionDTO>, Partial<SubscriptionDTO>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<SubscriptionDTO>()) : Partial<SubscriptionDTO>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<List<SubscriptionDTO>>("GET", $"api/http/applications/{application}/webhooks/{webhookId}/subscriptions{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "GetAllSubscriptions", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Update webhook subscription
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task<SubscriptionDTO> UpdateSubscriptionAsync(ApplicationIdentifier application, string webhookId, string subscriptionId, CustomGenericSubscriptionIn subscription, string? name = null, bool? enabled = null, Func<Partial<SubscriptionDTO>, Partial<SubscriptionDTO>>? partial = null, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                queryParameters.Append("$fields", (partial != null ? partial(new Partial<SubscriptionDTO>()) : Partial<SubscriptionDTO>.Default()).ToString());
                
                return await _connection.RequestResourceAsync<ApplicationsForApplicationWebhooksForWebhookIdSubscriptionsForSubscriptionIdPatchRequest, SubscriptionDTO>("PATCH", $"api/http/applications/{application}/webhooks/{webhookId}/subscriptions/{subscriptionId}{queryParameters.ToQueryString()}", 
                    new ApplicationsForApplicationWebhooksForWebhookIdSubscriptionsForSubscriptionIdPatchRequest
                    { 
                        Name = name,
                        IsEnabled = enabled,
                        Subscription = subscription,
                    }, requestHeaders: null, functionName: "UpdateSubscription", cancellationToken: cancellationToken);
            }
            
        
            /// <summary>
            /// Delete webhook subscription
            /// </summary>
            /// <remarks>
            /// Required permissions:
            /// <list type="bullet">
            /// <item>
            /// <term>Update applications</term>
            /// </item>
            /// </list>
            /// </remarks>
            public async Task DeleteSubscriptionAsync(ApplicationIdentifier application, string webhookId, string subscriptionId, Dictionary<string, string>? requestHeaders = null, CancellationToken cancellationToken = default)
            {
                var queryParameters = new NameValueCollection();
                
                await _connection.RequestResourceAsync("DELETE", $"api/http/applications/{application}/webhooks/{webhookId}/subscriptions/{subscriptionId}{queryParameters.ToQueryString()}", requestHeaders: null, functionName: "DeleteSubscription", cancellationToken: cancellationToken);
            }
            
        
        }
    
    }

}

